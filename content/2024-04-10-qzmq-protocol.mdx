---
title: "QZMQ: A Post-Quantum Transport Protocol"
date: "2024-04-10"
author: "Hanzo AI"
tags: ["qzmq", "post-quantum", "transport", "kdf", "key-schedule", "protocol-design"]
description: "QZMQ key schedule: HKDF-labeled QZMQ-v1-Handshake, client/server key+IV derivation, exporter secret, key ratcheting, 0-RTT early data, resumption secrets, and key usage budgets. Why a custom PQ transport."
---

QZMQ is a custom post-quantum transport protocol. It is not TLS 1.3 with a PQ extension. It is a transport designed from scratch with post-quantum key exchange as a first principle rather than a retrofit.

The key schedule is where protocol design becomes concrete. Here is how QZMQ derives its working key material.

## The Handshake Label

The master secret derivation uses HKDF with the label `QZMQ-v1-Handshake`. HKDF's structure is extract-then-expand:

1. **Extract**: Combine the input key material (the hybrid X25519+ML-KEM shared secret) with a salt to produce a pseudorandom key (PRK). The PRK has high entropy even if the IKM has low entropy.
2. **Expand**: Derive arbitrarily many bytes from the PRK using labeled HKDF-Expand calls. Each label produces an independent, indistinguishable-from-random output.

The `QZMQ-v1-Handshake` label anchors the entire key schedule to this specific protocol and version. A key derived under this label cannot be confused with a key derived under any other label or for any other protocol.

## Key and IV Derivation

From the handshake PRK, QZMQ derives separate keys and initialization vectors for each direction:

- `QZMQ-v1-ClientKey`: symmetric encryption key for client→server traffic
- `QZMQ-v1-ClientIV`: IV for client→server traffic
- `QZMQ-v1-ServerKey`: symmetric encryption key for server→client traffic
- `QZMQ-v1-ServerIV`: IV for server→client traffic

The separation of keys and IVs by direction means a server key compromise does not compromise client→server confidentiality, and vice versa. Directional keys are a baseline transport security requirement.

## Exporter Secret

The exporter secret allows application-layer protocols layered over QZMQ to derive their own key material bound to the specific QZMQ session:

```
exporter_secret = HKDF-Expand(PRK, "QZMQ-v1-Exporter", session_context)
```

An application can call `Export(label, length)` and receive key material that is bound to this session and this label. Two different applications using two different labels get independent, cryptographically separated key material from the same QZMQ session. This is the mechanism TLS 1.3 uses for exporters; QZMQ implements the same pattern.

## Key Ratcheting

After the handshake, keys are ratcheted. Each message updates the session key state:

```
next_key = HKDF-Expand(current_key, "QZMQ-v1-Ratchet", message_counter)
```

Ratcheting provides forward secrecy at the message level: compromising a key at message N does not compromise messages 1 through N-1, whose keys have already been ratcheted forward. After a key is used, it is derived forward and the old value is erased.

## 0-RTT Early Data

QZMQ supports 0-RTT early data using a resumption mechanism. A client with a previous session ticket can send data encrypted under early data keys on the first message, before the handshake completes. The early data label is `QZMQ-v1-EarlyData`.

0-RTT early data has a known limitation: it is vulnerable to replay attacks. An adversary who captures a 0-RTT message can resend it. QZMQ handles this through application-layer idempotency requirements on operations that accept 0-RTT data. The protocol documents which operation types are safe for 0-RTT and which require the full handshake.

## Resumption Secrets

Session tickets enable 0-RTT on subsequent connections. The resumption secret:

```
resumption_secret = HKDF-Expand(master_secret, "QZMQ-v1-Resumption", session_hash)
```

The session hash binds the resumption secret to the specific handshake transcript. A ticket forged without completing a real handshake cannot produce a valid resumption secret.

## Key Usage Budgets

QZMQ enforces key usage budgets per session key:

- **Max messages**: a session key is rotated after a configured number of messages, regardless of byte volume
- **Max bytes**: a session key is rotated after a configured number of bytes encrypted
- **Max age**: a session key is rotated after a configured time duration

When any budget is reached, a key update is triggered. The protocol requires the peer to acknowledge the key update before the session continues. Sessions that exceed a budget without update are terminated.

Key usage budgets prevent the cryptographic weaknesses that arise from encrypting too much data under a single key — nonce reuse risks with nonce-based AEADs, statistical attacks on large ciphertext volumes.

## Why Not TLS 1.3

TLS 1.3 is adding PQ support through extension mechanisms. IETF drafts for hybrid key exchange in TLS are in progress. The extension approach is correct for the general internet.

QZMQ is designed for Lux Network node-to-node communication where we control both endpoints. Designing the key schedule from scratch allowed decisions — the ratchet interval, the budget structure, the exporter interface — to be made for this specific use case rather than accommodating the full generality of the TLS ecosystem.

The `QZMQ-v1-*` label namespace makes the protocol fully versioned and self-describing. When `QZMQ-v2` is needed, no labels from v1 are reused.
