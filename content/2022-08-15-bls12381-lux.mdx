---
title: "BLS12-381 in Production: Signature Aggregation for the Lux Network"
date: "2022-08-15"
author: "Hanzo AI"
tags: ["bls12-381", "cryptography", "signatures", "lux", "consensus", "aggregation"]
description: "How BLS12-381 signature aggregation works in the Lux Network: G1 keys, G2 signatures, proof-of-possession, aggregate verification, and why all of this matters for a high-throughput consensus network."
---

BLS signatures on the BLS12-381 curve are the correct choice for a consensus network that needs to aggregate signatures across hundreds of validators. The Lux implementation uses Cloudflare's `circl` v1.6.2 and the `blst` v0.3.16 library via CGO.

## The Curve and the Pairing

BLS12-381 is a pairing-friendly elliptic curve. Pairings — the bilinear map e: G1 × G2 → GT — are what make BLS signatures work. The key insight: signature aggregation is possible because the pairing is bilinear.

The Lux implementation uses the conventional assignment: G1 for public keys, G2 for signatures. G1 is the smaller group (48-byte compressed points), so keys are compact. G2 signatures are 96 bytes compressed. This is the right tradeoff for a system where keys are stored and transmitted frequently and signatures are batch-processed.

## Domain Separation Tags

The implementation uses explicit DSTs (Domain Separation Tags) for all hash-to-curve operations. The signature DST is `BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_`. This is the IETF standard DST for BLS signatures over G2 with SHA-256 as the hash function. Using the standard DST prevents cross-protocol signature confusion.

The proof-of-possession DST is distinct from the signature DST. PoP and signing never share domain.

## Proof of Possession

Proof of Possession (PoP) solves the rogue key attack. Without PoP, an adversary can register a public key that is a function of other validators' keys, allowing them to forge aggregate signatures. PoP requires each validator to prove they hold the secret key corresponding to their registered public key by signing their own public key.

Before any key is used for consensus signing, the PoP is verified. The implementation enforces this: a key without a verified PoP cannot participate in aggregation.

## Aggregate Signatures and Keys

The aggregation operations:

```go
// Aggregate n signatures into one
aggSig := bls.AggregateSignatures(sigs)

// Aggregate n public keys into one
aggKey := bls.AggregatePublicKeys(keys)

// Verify the aggregate signature against the aggregate key
valid := bls.Verify(aggKey, message, aggSig)
```

An aggregate of 200 validator signatures verifies with a single pairing computation. Without aggregation, 200 separate `Verify` calls. The pairing is the expensive operation; aggregation converts O(n) pairings to O(1) for a fixed message.

For a consensus round requiring 2/3 quorum on a 300-validator network — 200+ signatures — this is the difference between verification being a bottleneck and verification being negligible.

## Identity Point Check

A critical safety property: the identity point (the group's zero element) is a valid EC point but is a degenerate key. A validator that registers the identity point as their public key can cause aggregate key computations to behave incorrectly. The implementation explicitly rejects identity points during key registration.

This is not an obvious check. It is also not optional. The blst library exposes `IsInfinity()` — the Lux code calls it.

## Why Aggregation Matters for Consensus

A consensus message with 200 validator signatures, without aggregation, is 200 × 96 = 19,200 bytes of signature data. With BLS aggregation, it is 96 bytes. One signature, any number of signers.

At the network layer, this is the difference between consensus messages that dominate bandwidth and consensus messages that are negligible overhead. At the verification layer, this is the difference between O(n) pairings per block and O(1). Neither is the bottleneck in a network that aggregates signatures correctly.

The Lux implementation covers the full BLS lifecycle: key generation, PoP generation and verification, signing, signature aggregation, key aggregation, and aggregate signature verification. The use of `blst` via CGO gives native performance for the expensive pairing operations while keeping the Go interface clean.

BLS12-381 is the production answer to signature aggregation for consensus networks. The Lux implementation is a correct, complete deployment of that answer.
